<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SDR Audio Stream</title>
</head>
<body>
  <h3>SDR Audio Stream (mono s16le @ 48k)</h3>
  <button id="start">Start</button>
  <script>
    const WS_URL = 'ws://localhost:8000';
    const startBtn = document.getElementById('start');

    startBtn.onclick = async () => {
      startBtn.disabled = true;

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
      // We'll use a ScriptProcessorNode (simple and widely supported).
      const bufferSize = 4096;
      const sp = audioCtx.createScriptProcessor(bufferSize, 1, 1);

      // Small FIFO to hold incoming samples
      let sampleQueue = new Float32Array(0);

      sp.onaudioprocess = (e) => {
        const out = e.outputBuffer.getChannelData(0);
        if (sampleQueue.length >= out.length) {
          out.set(sampleQueue.subarray(0, out.length));
          sampleQueue = sampleQueue.subarray(out.length);
        } else {
          // not enough data: fill remaining with zeros (silence)
          out.fill(0);
          if (sampleQueue.length > 0) {
            out.set(sampleQueue.subarray(0, sampleQueue.length));
            sampleQueue = new Float32Array(0);
          }
        }
      };

      sp.connect(audioCtx.destination);

      const ws = new WebSocket(WS_URL);
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => console.log('WS open');
      // Expect an initial JSON message with metadata
      let gotMeta = false;
      ws.onmessage = (ev) => {
        if (!gotMeta && typeof ev.data === 'string') {
          try {
            const meta = JSON.parse(ev.data);
            console.log('Meta:', meta);
            gotMeta = true;
            return;
          } catch (e) {
            // not JSON, fall through
          }
        }
        // Binary PCM s16le data
        if (ev.data instanceof ArrayBuffer) {
          const ab = ev.data;
          // Convert Int16 -> Float32 normalized
          const int16 = new Int16Array(ab);
          const float32 = new Float32Array(int16.length);
          for (let i = 0; i < int16.length; i++) {
            float32[i] = int16[i] / 32768; // normalize
          }
          // Append to queue (naive concat)
          const newQ = new Float32Array(sampleQueue.length + float32.length);
          newQ.set(sampleQueue, 0);
          newQ.set(float32, sampleQueue.length);
          sampleQueue = newQ;
        }
      };

      ws.onclose = () => console.log('WS closed');
      ws.onerror = (e) => console.error('WS err', e);
    };
  </script>
</body>
</html>
